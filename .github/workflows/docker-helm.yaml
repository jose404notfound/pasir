name: Deploy to AKS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Select environment (e.g. dev, prod)'
        required: true
        default: 'dev'  # Default to 'dev' if no input is provided

#  push:
#    branches:
#      - main 

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v2

      # Step 2: Set up Azure CLI
      # We need Azure CLI for interacting with Azure services like AKS and ACR
      - name: Set up Azure CLI
        uses: azure/setup-azurecli@v1

      # Step 3: Log in to Azure
      # This step is critical for authentication, ensuring we have the credentials to access Azure resources
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Step 4: Set up kubectl
      # `kubectl` is the CLI tool to interact with Kubernetes clusters
      - name: Set up kubectl
        uses: azure/setup-kubectl@v1

      # Step 5: Set up Helm
      # Helm is used for packaging and deploying applications in Kubernetes clusters
      - name: Set up Helm
        uses: azure/setup-helm@v1

      # Step 6: Get AKS credentials
      # This step retrieves the credentials for the AKS cluster to authenticate `kubectl` and `helm` commands
      - name: Get AKS credentials
        run: |
          az aks get-credentials --resource-group ${{ secrets.AKS_RG_NAME }} --name ${{ secrets.AKS_CLUSTER_NAME }}

      # Step 7: Build and push Docker images
      # Before deployment, we build the Docker images and push them to Docker Hub with multi-platform support

      # First, we set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      # Second, we build and push the Docker images for the web application and MySQL for both amd64 and arm64 architectures
      # This allows us to run the application on different platforms, ensuring compatibility with AKS and take the changes made in the Dockerfiles for deployment
      - name: Build and Push Docker Images
        run: |
          docker buildx build --platform linux/amd64,linux/arm64 -f ${{ env.WEBAPP_DOCKERFILE }} -t ${{ secrets.DOCKER_USERNAME }}/${{ env.WEBAPP_IMAGE }} --push .

          docker buildx build --platform linux/amd64,linux/arm64 -f ${{ env.MYSQL_DOCKERFILE }} -t ${{ secrets.DOCKER_USERNAME }}/${{ env.MYSQL_IMAGE }} --push .
        env:
          DOCKER_BUILDKIT: 1
          DOCKER_CLI_EXPERIMENTAL: enabled
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}  
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}

      # Step 8: Deploy application using Helm
      # Deploy or upgrade the application in the selected environment (dev, prod, etc.)
      - name: Deploy application using Helm
        run: |
          helm upgrade --install myapp ./helm --namespace ${{ inputs.environment }}

      # Step 9: Wait for 20 seconds to ensure deployment completes
      - name: Wait for 20 seconds
        run: |
          sleep 20

      # Step 10: Check the status of all resources in the AKS cluster
      - name: Check the status of all resources
        run: |
          kubectl get all --namespace ${{ inputs.environment }}
